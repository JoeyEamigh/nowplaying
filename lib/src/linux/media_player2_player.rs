//! # D-Bus interface proxy for: `org.mpris.MediaPlayer2.Player`
//!
//! This code was generated by `zbus-xmlgen` `5.0.1` from D-Bus introspection data.
//! Source: `media_player2.xml`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the [Writing a client proxy] section of the zbus
//! documentation.
//!
//! This type implements the [D-Bus standard interfaces], (`org.freedesktop.DBus.*`) for which the
//! following zbus API can be used:
//!
//! * [`zbus::fdo::PropertiesProxy`]
//! * [`zbus::fdo::IntrospectableProxy`]
//! * [`zbus::fdo::PeerProxy`]
//!
//! Consequently `zbus-xmlgen` did not generate code for the above interfaces.
//!
//! [Writing a client proxy]: https://dbus2.github.io/zbus/client.html
//! [D-Bus standard interfaces]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces,
use std::collections::HashMap;

use zbus::proxy;
use zvariant::{OwnedValue, Value};

#[proxy(
  interface = "org.mpris.MediaPlayer2.Player",
  default_path = "/org/mpris/MediaPlayer2",
  assume_defaults = true
)]
pub trait MediaPlayer2Player {
  /// Next method
  fn next(&self) -> zbus::Result<()>;

  /// OpenUri method
  fn open_uri(&self, uri: &str) -> zbus::Result<()>;

  /// Pause method
  fn pause(&self) -> zbus::Result<()>;

  /// Play method
  fn play(&self) -> zbus::Result<()>;

  /// PlayPause method
  fn play_pause(&self) -> zbus::Result<()>;

  /// Previous method
  fn previous(&self) -> zbus::Result<()>;

  /// Seek method
  fn seek(&self, offset: i64) -> zbus::Result<()>;

  /// SetPosition method
  fn set_position(&self, track_dd: &zbus::zvariant::ObjectPath<'_>, position: i64) -> zbus::Result<()>;

  /// SetVolume method
  fn set_volume(&self, volume: f64) -> zbus::Result<()>;

  /// Stop method
  fn stop(&self) -> zbus::Result<()>;

  /// Seeked signal
  #[zbus(signal)]
  fn seeked(&self, position: i64) -> zbus::Result<()>;

  /// CanControl property
  #[zbus(property)]
  fn can_control(&self) -> zbus::Result<bool>;

  /// CanGoNext property
  #[zbus(property)]
  fn can_go_next(&self) -> zbus::Result<bool>;

  /// CanGoPrevious property
  #[zbus(property)]
  fn can_go_previous(&self) -> zbus::Result<bool>;

  /// CanPause property
  #[zbus(property)]
  fn can_pause(&self) -> zbus::Result<bool>;

  /// CanPlay property
  #[zbus(property)]
  fn can_play(&self) -> zbus::Result<bool>;

  /// CanSeek property
  #[zbus(property)]
  fn can_seek(&self) -> zbus::Result<bool>;

  /// LoopStatus property
  #[zbus(property)]
  fn loop_status(&self) -> zbus::Result<LoopStatus>;
  #[zbus(property)]
  fn set_loop_status(&self, value: &str) -> zbus::Result<()>;

  /// MaximumRate property
  #[zbus(property)]
  fn maximum_rate(&self) -> zbus::Result<f64>;

  /// Metadata property
  #[zbus(property)]
  fn metadata(&self) -> zbus::Result<HashMap<String, OwnedValue>>;

  /// MinimumRate property
  #[zbus(property)]
  fn minimum_rate(&self) -> zbus::Result<f64>;

  /// PlaybackStatus property
  #[zbus(property)]
  fn playback_status(&self) -> zbus::Result<PlaybackStatus>;

  /// Position property
  #[zbus(property)]
  fn position(&self) -> zbus::Result<i64>;

  /// Rate property
  #[zbus(property)]
  fn rate(&self) -> zbus::Result<f64>;
  #[zbus(property)]
  fn set_rate(&self, value: f64) -> zbus::Result<()>;

  /// Shuffle property
  #[zbus(property)]
  fn shuffle(&self) -> zbus::Result<bool>;
  #[zbus(property)]
  fn set_shuffle(&self, value: bool) -> zbus::Result<()>;

  /// Volume property
  #[zbus(property)]
  fn volume(&self) -> zbus::Result<f64>;
}

#[derive(Debug)]
pub enum PlaybackStatus {
  Playing,
  Paused,
  Stopped,
}

impl TryFrom<Value<'_>> for PlaybackStatus {
  type Error = zvariant::Error;
  fn try_from(value: Value<'_>) -> Result<Self, Self::Error> {
    let value = value.downcast_ref::<String>()?;
    match value.as_str() {
      "Playing" => Ok(PlaybackStatus::Playing),
      "Paused" => Ok(PlaybackStatus::Paused),
      "Stopped" => Ok(PlaybackStatus::Stopped),
      _ => Err(zvariant::Error::Message("Invalid PlaybackStatus".to_string())),
    }
  }
}

impl TryFrom<OwnedValue> for PlaybackStatus {
  type Error = zvariant::Error;
  fn try_from(value: OwnedValue) -> Result<Self, Self::Error> {
    let value = value.downcast_ref::<String>()?;
    match value.as_str() {
      "Playing" => Ok(PlaybackStatus::Playing),
      "Paused" => Ok(PlaybackStatus::Paused),
      "Stopped" => Ok(PlaybackStatus::Stopped),
      _ => Err(zvariant::Error::Message("Invalid PlaybackStatus".to_string())),
    }
  }
}

impl From<bool> for PlaybackStatus {
  fn from(value: bool) -> Self {
    if value {
      PlaybackStatus::Playing
    } else {
      PlaybackStatus::Paused
    }
  }
}

#[derive(Debug)]
pub enum LoopStatus {
  None,
  Track,
  Playlist,
}

impl TryFrom<Value<'_>> for LoopStatus {
  type Error = zvariant::Error;
  fn try_from(value: Value<'_>) -> Result<Self, Self::Error> {
    let value = value.downcast_ref::<String>()?;
    match value.as_str() {
      "None" => Ok(LoopStatus::None),
      "Track" => Ok(LoopStatus::Track),
      "Playlist" => Ok(LoopStatus::Playlist),
      _ => Err(zvariant::Error::Message("Invalid LoopStatus".to_string())),
    }
  }
}

impl TryFrom<OwnedValue> for LoopStatus {
  type Error = zvariant::Error;
  fn try_from(value: OwnedValue) -> Result<Self, Self::Error> {
    let value = value.downcast_ref::<String>()?;
    match value.as_str() {
      "None" => Ok(LoopStatus::None),
      "Track" => Ok(LoopStatus::Track),
      "Playlist" => Ok(LoopStatus::Playlist),
      _ => Err(zvariant::Error::Message("Invalid LoopStatus".to_string())),
    }
  }
}

#[derive(Debug, Default, Clone)]
/// Represents the metadata of a media item.
pub struct Metadata {
  /// The track ID of the media item (mpris:trackid).
  pub track_id: String,
  /// The length of the media item in microseconds (mpris:length).
  pub length: Option<i64>,
  /// The URL of the album art (mpris:artUrl).
  pub art_url: Option<String>,
  /// The album title (xesam:album).
  pub album: Option<String>,
  /// The album artist(s) (xesam:albumArtist).
  pub album_artist: Option<Vec<String>>,
  /// The artist(s) (xesam:artist).
  pub artist: Option<Vec<String>>,
  /// The media item as text (xesam:asText).
  pub as_text: Option<String>,
  /// The audio BPM (beats per minute) (xesam:audioBPM).
  pub audio_bpm: Option<i32>,
  /// The auto rating (xesam:autoRating).
  pub auto_rating: Option<f64>,
  /// Comments about the media item (xesam:comment).
  pub comment: Option<Vec<String>>,
  /// The composer(s) (xesam:composer).
  pub composer: Option<Vec<String>>,
  /// The date the content was created (xesam:contentCreated).
  pub content_created: Option<String>,
  /// The disc number (xesam:discNumber).
  pub disc_number: Option<i32>,
  /// The date the media item was first used (xesam:firstUsed).
  pub first_used: Option<String>,
  /// The genre(s) (xesam:genre).
  pub genre: Option<Vec<String>>,
  /// The date the media item was last used (xesam:lastUsed).
  pub last_used: Option<String>,
  /// The lyricist(s) (xesam:lyricist).
  pub lyricist: Option<Vec<String>>,
  /// The title of the media item (xesam:title).
  pub title: Option<String>,
  /// The track number (xesam:trackNumber).
  pub track_number: Option<i32>,
  /// The URL of the media item (xesam:url).
  pub url: Option<String>,
  /// The number of times the media item has been used (xesam:useCount).
  pub use_count: Option<i32>,
  /// The user rating (xesam:userRating).
  pub user_rating: Option<f64>,
}

impl From<HashMap<String, OwnedValue>> for Metadata {
  fn from(map: HashMap<String, OwnedValue>) -> Self {
    let mut metadata = Metadata::default();

    for (key, value) in map {
      match key.as_str() {
        "mpris:trackid" => {
          if let Ok(s) = value.downcast_ref::<String>() {
            metadata.track_id = s;
          }
        }
        "mpris:length" => metadata.length = value.downcast_ref::<i64>().ok(),
        "mpris:artUrl" => metadata.art_url = value.downcast_ref::<String>().ok(),
        "xesam:album" => metadata.album = value.downcast_ref::<String>().ok(),
        "xesam:albumArtist" => {
          metadata.album_artist = <zvariant::Value<'_> as Clone>::clone(&value)
            .downcast::<Vec<String>>()
            .ok()
        }
        "xesam:artist" => {
          metadata.artist = <zvariant::Value<'_> as Clone>::clone(&value)
            .downcast::<Vec<String>>()
            .ok()
        }
        "xesam:asText" => metadata.as_text = value.downcast_ref::<String>().ok(),
        "xesam:audioBPM" => metadata.audio_bpm = value.downcast_ref::<i32>().ok(),
        "xesam:autoRating" => metadata.auto_rating = value.downcast_ref::<f64>().ok(),
        "xesam:comment" => {
          metadata.comment = <zvariant::Value<'_> as Clone>::clone(&value)
            .downcast::<Vec<String>>()
            .ok()
        }
        "xesam:composer" => {
          metadata.composer = <zvariant::Value<'_> as Clone>::clone(&value)
            .downcast::<Vec<String>>()
            .ok()
        }
        "xesam:contentCreated" => metadata.content_created = value.downcast_ref::<String>().ok(),
        "xesam:discNumber" => metadata.disc_number = value.downcast_ref::<i32>().ok(),
        "xesam:firstUsed" => metadata.first_used = value.downcast_ref::<String>().ok(),
        "xesam:genre" => {
          metadata.genre = <zvariant::Value<'_> as Clone>::clone(&value)
            .downcast::<Vec<String>>()
            .ok()
        }
        "xesam:lastUsed" => metadata.last_used = value.downcast_ref::<String>().ok(),
        "xesam:lyricist" => {
          metadata.lyricist = <zvariant::Value<'_> as Clone>::clone(&value)
            .downcast::<Vec<String>>()
            .ok()
        }
        "xesam:title" => metadata.title = value.downcast_ref::<String>().ok(),
        "xesam:trackNumber" => metadata.track_number = value.downcast_ref::<i32>().ok(),
        "xesam:url" => metadata.url = value.downcast_ref::<String>().ok(),
        "xesam:useCount" => metadata.use_count = value.downcast_ref::<i32>().ok(),
        "xesam:userRating" => metadata.user_rating = value.downcast_ref::<f64>().ok(),
        _ => {}
      }
    }

    metadata
  }
}
